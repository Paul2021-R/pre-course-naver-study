# 2025년 9월 2일: 문제 해결의 두 가지 접근법에 대한 고찰

오늘 프로그래머스 코딩 테스트 문제 하나를 붙잡고 꽤 오랜 시간 고민했다. '택배 상자 쌓기' 문제였는데, 단순히 해결하는 것을 넘어 '어떻게 더 잘 해결할 수 있을까?'에 대한 깊은 생각에 잠기게 한 문제였다.

### 첫 번째 접근: 눈에 보이는 대로, 직관적인 시뮬레이션

문제의 요구사항은 명확했다. 지그재그 방식으로 쌓이는 택배 상자들 중에서 특정 번호의 상자를 꺼내기 위해 위에 놓인 상자가 몇 개인지 세는 것이었다. 가장 먼저 떠오른 방법은 역시 '시뮬레이션'이었다.

1.  **전체 구조 파악:** 상자가 쌓일 공간을 2차원 배열로 구상했다.
2.  **규칙 적용:** 문제에 명시된 규칙 그대로, 층(row)마다 방향을 바꿔가며 상자 번호를 채워 넣었다.
3.  **좌표 탐색 및 계산:** 목표 상자의 좌표(x, y)를 찾고, 그 위층(y+1, y+2, ...)의 같은 x 좌표에 상자가 있는지 확인하며 개수를 셌다.

이 방식은 직관적이고 명쾌했다. 머릿속으로 그리는 과정을 코드로 그대로 옮기면 되니, 논리적 오류가 발생할 확률도 적었다. 문제의 제약 조건(n ≤ 100)이 크지 않았기에, 이 방법으로도 충분히 '정답'을 맞힐 수 있었다.

하지만 마음 한편에는 찜찜함이 남았다. 만약 상자가 100개가 아니라 100만 개, 1억 개가 된다면? 이 거대한 2차원 배열을 메모리에 올리는 것부터가 부담이 될 터였다. (물론 이 문제의 제약은 아니었지만, 언제나 최적화를 염두에 두는 습관을 들이고 싶다.)

### 두 번째 접근: 패턴을 꿰뚫는 수학적 계산

고민의 지점에서, 나는 다른 접근법을 모색했다. 바로 '배열 없는 계산'이다.

핵심은 **"어떤 상자 번호(k)가 주어지면, 그 상자의 좌표(x, y)를 즉시 계산해낼 수 있는가?"** 였다. 상자가 쌓이는 규칙은 명확한 패턴을 가지고 있었기에, 충분히 가능해 보였다.

-   **y좌표 (층):** `(k-1) // w` 로 간단히 계산할 수 있다.
-   **x좌표 (칸):** 층(y)이 짝수냐 홀수냐에 따라 계산 방식이 달라진다.
    -   짝수 층: 왼쪽에서 오른쪽으로 가므로 `(k-1) % w`
    -   홀수 층: 오른쪽에서 왼쪽으로 가므로 `w - 1 - ((k-1) % w)`

이 좌표 계산 함수 `get_coords(k)`를 정의하고 나니, 문제는 훨씬 단순해졌다.

1.  목표 상자(`num`)의 좌표 `(target_x, target_y)`를 구한다.
2.  `num + 1`번 상자부터 `n`번 상자까지 루프를 돈다.
3.  각 상자의 x좌표를 계산해서 `target_x`와 같은지 확인하고, 같다면 카운트를 1 늘린다.

이 방식은 불필요한 배열 생성을 완전히 제거하여 메모리 사용량을 극도로 줄였고, 전체 시뮬레이션 과정 없이 필요한 계산만 수행하므로 속도도 훨씬 빨랐다.

### 오늘의 교훈: 본질을 향한 집요함

오늘의 경험은 나에게 중요한 교훈을 남겼다. 첫 번째 풀이(시뮬레이션)에 만족하고 넘어갔다면, 그저 '문제 하나를 풀었다'에서 그쳤을 것이다. 하지만 "더 나은 방법은 없을까?"라는 질문을 던졌기에, 문제의 표면 아래에 숨겨진 수학적 패턴을 발견하고 더 효율적인 코드를 작성할 수 있었다.

코딩 테스트는 단순히 정답을 맞히는 게임이 아니라, 문제 해결을 위한 최적의 경로를 찾는 훈련 과정임을 다시 한번 깨닫는다. 눈앞의 문제를 해결하는 것에 급급하기보다, 그 문제의 본질이 무엇인지 꿰뚫어 보려는 집요한 자세를 잃지 말아야겠다. 그것이 곧 실력의 깊이를 더하는 길일 테니.
